#!/usr/bin/env tsx
/**
 * Generates TypeScript types for VS Code semantic token types.
 * Fetches definitions from VS Code's source.
 *
 * Run: npx tsx tools/generateSemanticTokenTypes.ts
 */

import { writeFile } from 'fs/promises';
import { dirname, join } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));

const TOKEN_REGISTRY_URL =
  'https://raw.githubusercontent.com/microsoft/vscode/main/src/vs/platform/theme/common/tokenClassificationRegistry.ts';

const SEMANTIC_TOKENS_URL =
  'https://raw.githubusercontent.com/microsoft/vscode/main/src/vs/editor/common/services/semanticTokensProviderStyling.ts';

async function fetchFile(url: string): Promise<string> {
  console.log(`Fetching ${url.split('/').pop()}...`);
  const response = await fetch(url);
  if (!response.ok) {
    console.warn(`Failed to fetch ${url}: ${response.status}`);
    return '';
  }
  return response.text();
}

function extractTokenTypes(source: string): string[] {
  const types: string[] = [];

  // Match TokenType enum or registerTokenType patterns
  // Look for patterns like: registerTokenType('namespace', ...)
  const registerRegex = /registerTokenType\(\s*['"]([^'"]+)['"]/g;
  let match;
  while ((match = registerRegex.exec(source)) !== null) {
    types.push(match[1]);
  }

  // Also look for SemanticTokenTypes enum
  const enumRegex = /SemanticTokenTypes\.(\w+)/g;
  while ((match = enumRegex.exec(source)) !== null) {
    // Convert PascalCase to camelCase
    const name = match[1].charAt(0).toLowerCase() + match[1].slice(1);
    types.push(name);
  }

  return types;
}

function extractModifiers(source: string): string[] {
  const modifiers: string[] = [];

  // Look for SemanticTokenModifiers enum
  const enumRegex = /SemanticTokenModifiers\.(\w+)/g;
  let match;
  while ((match = enumRegex.exec(source)) !== null) {
    const name = match[1].charAt(0).toLowerCase() + match[1].slice(1);
    modifiers.push(name);
  }

  // Also look for registerTokenModifier patterns
  const registerRegex = /registerTokenModifier\(\s*['"]([^'"]+)['"]/g;
  while ((match = registerRegex.exec(source)) !== null) {
    modifiers.push(match[1]);
  }

  return modifiers;
}

async function main() {
  console.log('Fetching VS Code semantic token definitions...\n');

  const [registrySource, semanticSource] = await Promise.all([
    fetchFile(TOKEN_REGISTRY_URL),
    fetchFile(SEMANTIC_TOKENS_URL),
  ]);

  const combinedSource = registrySource + semanticSource;

  // Standard LSP semantic token types (from LSP spec)
  const lspTokenTypes = [
    'namespace',
    'type',
    'class',
    'enum',
    'interface',
    'struct',
    'typeParameter',
    'parameter',
    'variable',
    'property',
    'enumMember',
    'event',
    'function',
    'method',
    'macro',
    'keyword',
    'modifier',
    'comment',
    'string',
    'number',
    'regexp',
    'operator',
    'decorator',
  ];

  // Standard LSP modifiers
  const lspModifiers = [
    'declaration',
    'definition',
    'readonly',
    'static',
    'deprecated',
    'abstract',
    'async',
    'modification',
    'documentation',
    'defaultLibrary',
  ];

  // Extract additional types from VS Code source
  const extractedTypes = extractTokenTypes(combinedSource);
  const extractedModifiers = extractModifiers(combinedSource);

  // Combine and deduplicate
  const allTypes = [...new Set([...lspTokenTypes, ...extractedTypes])].sort();
  const allModifiers = [...new Set([...lspModifiers, ...extractedModifiers])].sort();

  console.log(`\nFound ${allTypes.length} token types`);
  console.log(`Found ${allModifiers.length} modifiers`);

  const output = `// ==========================================================================
// Auto-generated by tools/generateSemanticTokenTypes.ts - DO NOT EDIT MANUALLY
// Run: npx tsx tools/generateSemanticTokenTypes.ts
// Sources: LSP specification + VS Code source
// ==========================================================================

/**
 * Standard semantic token types from LSP specification.
 * https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#semanticTokenTypes
 */
export type StandardSemanticTokenType =
${lspTokenTypes.map((t) => `  | "${t}"`).join('\n')};

/**
 * Additional semantic token types used by VS Code and language extensions.
 */
export type ExtendedSemanticTokenType =
${
  extractedTypes
    .filter((t) => !lspTokenTypes.includes(t))
    .map((t) => `  | "${t}"`)
    .join('\n') || '  | never'
};

/**
 * All semantic token types (standard + extended).
 */
export type SemanticTokenType =
  | StandardSemanticTokenType
  | ExtendedSemanticTokenType;

/**
 * Semantic token modifiers from LSP specification.
 */
export type StandardSemanticTokenModifier =
${lspModifiers.map((m) => `  | "${m}"`).join('\n')};

/**
 * Additional semantic token modifiers from VS Code.
 */
export type ExtendedSemanticTokenModifier =
${
  extractedModifiers
    .filter((m) => !lspModifiers.includes(m))
    .map((m) => `  | "${m}"`)
    .join('\n') || '  | never'
};

/**
 * All semantic token modifiers.
 */
export type SemanticTokenModifier =
  | StandardSemanticTokenModifier
  | ExtendedSemanticTokenModifier;

/**
 * Wildcard selectors with modifiers (shown in VS Code autocomplete).
 * These apply to ALL token types that have the specified modifier.
 */
export type WildcardModifierSelector = \`*.\${SemanticTokenModifier}\`;

/**
 * Semantic token selector that can include modifiers and language scopes.
 *
 * VS Code's selector pattern: ^(tokenType|*)(.modifier)*(:language)?$
 *
 * Examples:
 * - "variable" - simple token type
 * - "*.readonly" - wildcard: all readonly tokens
 * - "variable.readonly" - type with one modifier
 * - "variable.readonly.deprecated" - type with multiple modifiers
 * - "variable:typescript" - with language scope
 *
 * Note: VS Code autocomplete shows token types and *.modifier patterns.
 * Compound selectors (type.modifier.modifier) ARE valid but not shown in autocomplete.
 */
export type SemanticTokenSelector =
  // Token types (primary autocomplete options)
  | SemanticTokenType
  // Wildcard with modifier (shown in VS Code autocomplete as *.abstract, *.readonly, etc.)
  | WildcardModifierSelector
  // Type with one modifier
  | \`\${SemanticTokenType}.\${SemanticTokenModifier}\`
  // Type with two modifiers (valid but not shown in autocomplete)
  | \`\${SemanticTokenType}.\${SemanticTokenModifier}.\${SemanticTokenModifier}\`
  // Type with language scope
  | \`\${SemanticTokenType}:\${string}\`
  // Escape hatch for extension-provided types (memberOperatorOverload, tomlArrayKey, etc.)
  | (string & {});

/**
 * Array of all standard token types.
 */
export const standardSemanticTokenTypes: StandardSemanticTokenType[] = [
${lspTokenTypes.map((t) => `  "${t}",`).join('\n')}
];

/**
 * Array of all token modifiers.
 */
export const semanticTokenModifiers: SemanticTokenModifier[] = [
${allModifiers.map((m) => `  "${m}",`).join('\n')}
];

/**
 * Wildcard selectors (shown in VS Code autocomplete).
 * These match any token type with the specified modifier.
 */
export const wildcardSelectors: WildcardModifierSelector[] = [
${allModifiers.map((m) => `  "*.${m}",`).join('\n')}
];
`;

  const outputPath = join(__dirname, '../generated/semanticTokenTypes.ts');
  await writeFile(outputPath, output);

  console.log(`\nâœ“ Generated src/semanticTokenTypes.ts`);
  console.log(`  - ${allTypes.length} token types`);
  console.log(`  - ${allModifiers.length} modifiers`);
}

main().catch(console.error);
